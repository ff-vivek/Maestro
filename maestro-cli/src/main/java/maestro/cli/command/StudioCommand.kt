package maestro.cli.command

import maestro.cli.App
import maestro.cli.CliError
import maestro.cli.DisableAnsiMixin
import maestro.cli.ShowHelpMixin
import maestro.cli.report.TestDebugReporter
import maestro.cli.session.MaestroSessionManager
import maestro.cli.view.blue
import maestro.cli.view.bold
import maestro.cli.view.box
import maestro.cli.view.faint
import maestro.orchestra.workspace.WorkspaceExecutionPlanner
import maestro.orchestra.yaml.YamlCommandReader
import maestro.studio.MaestroStudio
import picocli.CommandLine
import java.awt.Desktop
import java.io.File
import java.net.URI
import java.util.concurrent.Callable
import maestro.cli.util.getFreePort
import picocli.CommandLine.Option
import kotlin.io.path.exists

@CommandLine.Command(
    name = "studio",
    hidden = true,
    description = ["Launch Maestro Studio"],
)
class StudioCommand : Callable<Int> {

    @CommandLine.Mixin
    var disableANSIMixin: DisableAnsiMixin? = null

    @CommandLine.Mixin
    var showHelpMixin: ShowHelpMixin? = null

    @CommandLine.ParentCommand
    private val parent: App? = null

    @Option(
        names = ["--debug-output"],
        description = ["Configures the debug output in this path, instead of default"]
    )
    private var debugOutput: String? = null

    @Option(
        names = ["--no-window"],
        description = ["When set, a browser window will not be automatically opened"]
    )
    private var noWindow: Boolean? = null

    @Option(
        names = ["--android-webview-hierarchy"],
        description = ["Set to \"devtools\" to use Chrome dev tools for Android WebView hierarchy"],
        hidden = true,
    )
    private var androidWebViewHierarchy: String? = null

    @Option(
        names = ["--apple-team-id"],
        description = ["The Team ID is a unique 10-character string generated by Apple that is assigned to your team's apple account."]
    )
    private var appleTeamId: String? = null

    @Option(
        names = ["--config"],
        description = ["Path to config.yaml file or workspace directory containing config.yaml. Required for web platform features like selectorAliases."]
    )
    private var configPath: File? = null

    override fun call(): Int {
        println()
        println("""
        ╭────────────────────────────────────────────────────────────────────────────────╮
        │                                                                                │
        │          Download the new and improved Maestro Studio app today!               │
        │                                                                                │
        │ https://maestro.dev?utm_source=cli&utm_campaign=download_studio#maestro-studio │
        │                                                                                │
        ╰────────────────────────────────────────────────────────────────────────────────╯""".trimIndent().bold())
        println()

        TestDebugReporter.install(debugOutputPathAsString = debugOutput, printToConsole = parent?.verbose == true)

        // Build execution plan from config if provided
        val executionPlan = configPath?.let { path ->
            val configFile = if (path.isDirectory) {
                // Look for config.yaml or config.yml in the directory
                val yamlPath = path.toPath().resolve("config.yaml")
                val ymlPath = path.toPath().resolve("config.yml")
                when {
                    yamlPath.exists() -> yamlPath.toFile()
                    ymlPath.exists() -> ymlPath.toFile()
                    else -> throw CliError("No config.yaml or config.yml found in ${path.absolutePath}")
                }
            } else {
                if (!path.exists()) {
                    throw CliError("Config file does not exist: ${path.absolutePath}")
                }
                path
            }
            
            val workspaceConfig = YamlCommandReader.readWorkspaceConfig(configFile.toPath())
            WorkspaceExecutionPlanner.ExecutionPlan(
                flowsToRun = emptyList(),
                sequence = WorkspaceExecutionPlanner.FlowSequence(emptyList()),
                workspaceConfig = workspaceConfig
            )
        }

        MaestroSessionManager.newSession(
            host = parent?.host,
            port = parent?.port,
            driverHostPort = null,
            teamId = appleTeamId,
            deviceId = parent?.deviceId,
            platform = parent?.platform,
            isStudio = true,
            executionPlan = executionPlan,
        ) { session ->
            session.maestro.setAndroidChromeDevToolsEnabled(androidWebViewHierarchy == "devtools")

            val port = getFreePort()
            val selectorAliases = executionPlan?.workspaceConfig?.platform?.web?.selectorAliases ?: emptyMap()
            MaestroStudio.start(port, session.maestro, selectorAliases)

            val studioUrl = "http://localhost:${port}"
            val message = ("Maestro Studio".bold() + " is running at " + studioUrl.blue()).box()
            println()
            println(message)
            tryOpenUrl(studioUrl)


            println()
            println("Tip: Maestro Studio can now run simultaneously alongside other Maestro CLI commands!")

            println()
            println("Navigate to $studioUrl in your browser to open Maestro Studio. Ctrl-C to exit.".faint())

            Thread.currentThread().join()
        }

        TestDebugReporter.deleteOldFiles()
        return 0
    }

    private fun tryOpenUrl(studioUrl: String) {
        try {
            if (Desktop.isDesktopSupported() && noWindow != true) {
                Desktop.getDesktop().browse(URI(studioUrl))
            }
        } catch (ignore: Exception) {
            // Do nothing
        }
    }

}
